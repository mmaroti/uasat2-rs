# Copyright (C) 2025, Miklos Maroti
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from typing import List, Optional

from ._uasat import Solver, BitVec
from .operation import Operation
from .relation import Relation


class CriticalRels:
    """
    This class helps to find critical relations for a clone generated by
    a set of operations.
    """

    def __init__(self, size: int, operations: List[Operation], arity: int):
        """
        You need to specify the size of the universe, the list of operations
        and the arity of the critical relation you want to find.
        """
        assert all(o.size == size for o in operations)

        self.size = size
        self.operations = operations
        self.arity = arity
        self.relations: List[Relation] = []

    def add_relation(self, relation: Relation):
        """
        Adds the given relation, which must itself be critical, to the list of
        generator relations. First the coordinates of the relation are permuted
        and extended with dummy coordinates (cartesian product with the full
        relation) to generate all possible minions and then these are added to
        the list of already known critical relations.
        """
        assert not relation.solver
        assert relation.size == self.size
        assert relation.arity <= self.arity

        coords: List[List[int]] = [[]]
        for _ in range(relation.arity):
            coords2 = []
            for c in coords:
                for i in range(self.arity):
                    if i not in c:
                        d = list(c)
                        d.append(i)
                        coords2.append(d)
            coords = coords2

        for c in coords:
            r = relation.polymer(c, self.arity)
            if r not in self.relations:
                self.relations.append(r)

    def find_next(self) -> Optional[Relation]:
        """
        Finds a maximal relation comatible with the list of operations which
        is not the intersection of all relations added to this class. The
        returned relation is necessarily will be a new critical relation. If
        such a relation is found, then it will be automatically added to the
        list of known critical relations.
        """
        base = None
        while True:
            solver = Solver()

            rel = Relation.variable(self.size, self.arity, solver)

            if base is not None:
                (~base | rel).ensure_all()
                (~base & rel).ensure_any()

            for o in self.operations:
                o.preserves(rel).ensure_true()

            extra = Relation.variable(self.size, self.arity, solver)
            (~rel & extra).ensure_any()

            for r in self.relations:
                a = (~rel | r).fold_all()
                b = (~extra | r).fold_all()
                (~a | b).ensure_true()

            if not solver.solve():
                if base is not None:
                    self.add_relation(base)
                return base

            base = rel.solution()
