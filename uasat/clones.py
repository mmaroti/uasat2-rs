# Copyright (C) 2025, Miklos Maroti
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from typing import List, Optional

from ._uasat import Solver, BitVec
from .operation import Operation
from .relation import Relation


class Clone:
    def __init__(self, operations: List[Operation], relations: List[Relation]):
        self.operations = operations
        self.relations = relations

    def __repr__(self) -> str:
        return f"Clone({self.operations}, {self.relations})"


def preserves(operations: List[Operation], relations: List[Relation]) -> BitVec:
    t = BitVec(Solver.CALC, [Solver.TRUE])
    for o in operations:
        for r in relations:
            t &= o.preserves(r)
    return t


class MinimalClones:
    def __init__(self, size: int,
                 max_relation_arity: int):
        self.size = size
        self.max_relation_arity = max_relation_arity
        self.minimal_clones: List[Clone] = []

    def maltsev_condition(self, solver: Solver) -> List[Operation]:
        raise NotImplementedError()

    def find_minimal(self, relations: List[Relation],
                     avoid_existing: bool = True) -> Optional[Clone]:
        """
        Finds a quasi-minimal clone generated by the maltsev condition
        operations, which is below the polymorphism clone of the given list
        of input relations. The input relations are extended up to the
        maximum relation arity to make this clone as minimal as possible.
        If avoid_existing is true, then the set of relations is extended
        first to avoid all existing minimal clones. If avoid_existing is
        false, then the caller must guarantee that none of the existing
        minimal clones are below the polymorphism clone of the input
        relations.
        """
        relations = list(relations)

        solver = Solver()
        operations = self.maltsev_condition(solver)
        preserves(operations, relations).ensure_true()

        new_relations: List[Relation] = []
        if avoid_existing:
            for c in self.minimal_clones:
                if not preserves(c.operations, relations).value():
                    continue

                new_relation = Relation.variable(
                    self.size, self.max_relation_arity, solver)
                new_relations.append(new_relation)

                preserves(operations, [new_relation]).ensure_true()
                preserves(c.operations, [new_relation]).ensure_false()

        if not solver.solve():
            return None

        operations = [o.solution() for o in operations]
        relations.extend([r.solution() for r in new_relations])

        for relation_arity in range(1, self.max_relation_arity + 1):
            while True:
                solver = Solver()
                new_operations = self.maltsev_condition(solver)
                preserves(new_operations, relations).ensure_true()

                new_relation = Relation.variable(
                    self.size, relation_arity, solver)
                preserves(new_operations, [new_relation]).ensure_true()
                preserves(operations, [new_relation]).ensure_false()

                if not solver.solve():
                    break

                operations = [o.solution() for o in new_operations]
                relations.append(new_relation.solution())

        clone = Clone(operations, relations)
        print("Adding minimal clone", clone)
        self.minimal_clones.append(clone)
        return clone


class MaximalClones(MinimalClones):
    def __init__(self, size: int,
                 max_relation_arity: int,
                 max_operation_arity: int):
        MinimalClones.__init__(self, size, max_operation_arity)
        self.max_operation_arity = max_operation_arity
        self.maximal_clones: List[Clone] = []

    def relation_condition(self, solver: Solver) -> List[Relation]:
        raise NotImplementedError()

    def find_maximal(self, operations: List[Operation],
                     avoid_existing: bool = True) -> Optional[Clone]:
        """
        Finds a quasi-maximal clone given by the polimorphism clone of a
        relation condition, which is not above any of the quasi-minimal
        clones and it is above the clone generated by the given list of input
        operations. The input operations are extended up to the maximum
        operation arity to make this polimorphism clone as maximal as possible.
        If avoid_existing is true, then the set of operations is extended
        first to avoid all existing maximal clones. If avoid_existing is
        false, then the caller must guarantee that none of the existing
        maximal clones are above the clone generated by the input operations.
        """
        operations = list(operations)

        while True:
            solver = Solver()

            relations = self.relation_condition(solver)
            preserves(operations, relations).ensure_true()

            for c in self.minimal_clones:
                preserves(c.operations, relations).ensure_false()

            new_operations = []
            if avoid_existing:
                for c in self.maximal_clones:
                    if not preserves(operations, c.relations).value():
                        continue

                    new_operation = Operation.variable(
                        self.size, self.max_operation_arity, solver)
                    new_operations.append(new_operation)

                    preserves([new_operation], relations).ensure_true()
                    preserves([new_operation], c.relations).ensure_false()

            if not solver.solve():
                return None

            relations = [r.solution() for r in relations]

            clone = self.find_minimal(relations, avoid_existing=False)
            if clone is None:
                operations.extend([o.solution() for o in new_operations])
                break

        for operation_arity in range(1, self.max_operation_arity + 1):
            while True:
                solver = Solver()

                new_relations = self.relation_condition(solver)
                preserves(operations, new_relations).ensure_true()

                for c in self.minimal_clones:
                    preserves(c.operations, new_relations).ensure_false()

                new_operation = Operation.variable(
                    self.size, operation_arity, solver)

                preserves([new_operation], new_relations).ensure_true()
                preserves([new_operation], relations).ensure_false()

                if not solver.solve():
                    break

                new_relations = [r.solution() for r in new_relations]
                new_operation = new_operation.solution()

                clone = self.find_minimal(new_relations, avoid_existing=False)

                if clone is None:
                    print("Adding new lower operation", new_operation)
                    relations = new_relations
                    operations.append(new_operation)

        clone = Clone(operations, relations)
        print("Adding maximal clone", clone)
        self.maximal_clones.append(clone)
        return clone
