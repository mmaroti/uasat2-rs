# Copyright (C) 2025, Miklos Maroti
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from typing import List, Optional

from uasat import Solver, BitVec, Relation, Operation


class Clone:
    def __init__(self, operations: List[Operation], relations: List[Relation]):
        self.operations = operations
        self.relations = relations

    def __repr__(self) -> str:
        return f"Clone({self.operations}, {self.relations})"


def preserves(operations: List[Operation], relations: List[Relation]) -> BitVec:
    t = BitVec(Solver.CALC, [Solver.TRUE])
    for o in operations:
        for r in relations:
            t &= o.preserves(r)
    return t


class MaximalClones:
    def __init__(self, size: int,
                 max_relation_arity: int,
                 max_operation_arity: int):
        self.size = size
        self.max_relation_arity = max_relation_arity
        self.max_operation_arity = max_operation_arity
        self.minimal_clones: List[Clone] = []

    def maltsev_condition(self, solver: Solver) -> List[Operation]:
        raise NotImplementedError()

    def relation_condition(self, solver: Solver) -> List[Relation]:
        raise NotImplementedError()

    def find_minimal(self, relations: List[Relation]) -> Optional[Clone]:
        """
        Finds a quasi-minimal clone generated by the maltsev condition
        operations, which is below the polymorphism clone of the given list
        of input relations. The input relations are extended up to the
        maximum relation arity to make this clone as minimal as possible.
        """
        relations = list(relations)

        solver = Solver()
        operations = self.maltsev_condition(solver)
        preserves(operations, relations).ensure_true()
        if not solver.solve():
            return None

        operations = [o.solution() for o in operations]

        for relation_arity in range(1, self.max_relation_arity + 1):
            while True:
                solver = Solver()
                new_operations = self.maltsev_condition(solver)
                preserves(new_operations, relations).ensure_true()

                new_relation = Relation.variable(
                    self.size, relation_arity, solver)
                preserves(new_operations, [new_relation]).ensure_true()
                preserves(operations, [new_relation]).ensure_false()

                if not solver.solve():
                    break

                operations = [o.solution() for o in new_operations]
                relations.append(new_relation.solution())

        return Clone(operations, relations)

    def find_maximal(self, operations: List[Operation]) -> Optional[Clone]:
        operations = list(operations)

        while True:
            solver = Solver()

            relations = self.relation_condition(solver)
            preserves(operations, relations).ensure_true()

            for c in self.minimal_clones:
                preserves(c.operations, relations).ensure_false()

            if not solver.solve():
                return None

            relations = [r.solution() for r in relations]

            clone = self.find_minimal(relations)
            if clone is None:
                break

            print("Adding minimal clone", clone)
            self.minimal_clones.append(clone)

        for operation_arity in range(1, self.max_operation_arity + 1):
            while True:
                solver = Solver()

                new_relations = self.relation_condition(solver)
                preserves(operations, new_relations).ensure_true()

                for c in self.minimal_clones:
                    preserves(c.operations, new_relations).ensure_false()

                new_operation = Operation.variable(
                    self.size, operation_arity, solver)

                preserves([new_operation], new_relations).ensure_true()
                preserves([new_operation], relations).ensure_false()

                if not solver.solve():
                    break

                new_relations = [r.solution() for r in new_relations]
                new_operation = new_operation.solution()

                clone = self.find_minimal(new_relations)

                if clone is None:
                    print("Adding new lower operation", new_operation)
                    relations = new_relations
                    operations.append(new_operation)
                else:
                    print("Adding minimal clone", clone)
                    self.minimal_clones.append(clone)

        return Clone(operations, relations)


class MaximalMaltsev(MaximalClones):
    def __init__(self, size: int,
                 max_relation_arity: int,
                 max_operation_arity: int):
        MaximalClones.__init__(self, size,
                               max_relation_arity,
                               max_operation_arity)

    def maltsev_condition(self, solver: Solver) -> List[Operation]:
        oper = Operation.variable(self.size, 3, solver)

        oper.polymer([0, 1, 1]).comp_eq(
            Operation.projection(self.size, 2, 0)).ensure_true()
        oper.polymer([0, 0, 1]).comp_eq(
            Operation.projection(self.size, 2, 1)).ensure_true()

        return [oper]

    def singletons(self) -> List[Relation]:
        return [Relation.singleton(self.size, [i]) for i in range(self.size)]

    def relation_condition_base(self, solver: Solver) -> List[Relation]:
        relations = self.singletons()
        relations.append(Relation.variable(self.size, 3, solver))
        relations.append(Relation.variable(self.size, 3, solver))
        return relations

    def relation_condition_refl(self, solver: Solver) -> List[Relation]:
        relations = self.singletons()
        relations.append(Relation.variable(self.size, 3, solver))
        relations[-1].reflexive().ensure_true()
        return relations

    def relation_condition_binary(self, solver: Solver) -> List[Relation]:
        relations = self.singletons()
        relations.append(Relation.variable(self.size, 2, solver))
        return relations

    def relation_condition(self, solver: Solver) -> List[Relation]:
        relations = self.singletons()
        relations.append(Relation.variable(self.size, 3, solver))
        relations[-1].fold_amo(1).fold_all().ensure_true()
        return relations


def test_maximal_maltsev():
    clones = MaximalMaltsev(3, 3, 3)
    # print(clones.find_maximal([]))
    print(clones.find_maximal([Operation(3, 2, [0, 2, 1, 0, 1, 0, 0, 0, 2])]))


if __name__ == '__main__':
    test_maximal_maltsev()
